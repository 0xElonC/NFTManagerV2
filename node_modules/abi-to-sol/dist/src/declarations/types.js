"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.from = exports.merge = exports.empty = void 0;
const identifier_1 = require("./identifier");
const kind_1 = require("./kind");
/**
 * Initialize an empty set of declarations
 */
const empty = () => ({
    byIdentifierReference: {},
    globalIdentifiers: new Set([]),
    identifiersByContainer: {},
    unnamedBySignature: {}
});
exports.empty = empty;
/**
 * Merge two sets of declarations
 */
const merge = (a, b) => ({
    byIdentifierReference: Object.assign(Object.assign({}, a.byIdentifierReference), b.byIdentifierReference),
    unnamedBySignature: Object.assign(Object.assign({}, a.unnamedBySignature), b.unnamedBySignature),
    globalIdentifiers: new Set([
        ...a.globalIdentifiers,
        ...b.globalIdentifiers
    ]),
    identifiersByContainer: mergeIdentifiersByContainer(a.identifiersByContainer, b.identifiersByContainer)
});
exports.merge = merge;
/**
 * Generate declarations to include a single Kind.
 * Note! This does not recurse; e.g. it returns empty() for arrays always
 */
const from = (kind) => {
    if (kind_1.Kind.isInterface(kind)) {
        return fromInterface(kind);
    }
    if (kind_1.Kind.isStruct(kind)) {
        return fromStruct(kind);
    }
    if (kind_1.Kind.isUserDefinedValueType(kind)) {
        return fromUserDefinedValueType(kind);
    }
    ;
    return (0, exports.empty)();
};
exports.from = from;
const fromUserDefinedValueType = (kind) => {
    const { identifier } = kind;
    const reference = identifier_1.Identifier.toReference(identifier);
    const { container } = identifier;
    // globally-defined case
    if (!container) {
        return {
            byIdentifierReference: {
                [reference]: kind
            },
            unnamedBySignature: {},
            globalIdentifiers: new Set([reference]),
            identifiersByContainer: {}
        };
    }
    // defined inside containing contract/interface
    const containerDeclarations = fromInterface({ identifier: container });
    const containerReference = identifier_1.Identifier.toReference(container);
    return (0, exports.merge)(containerDeclarations, {
        byIdentifierReference: {
            [reference]: kind,
        },
        unnamedBySignature: {},
        globalIdentifiers: new Set([]),
        identifiersByContainer: {
            [containerReference]: new Set([reference])
        }
    });
};
const fromStruct = (kind) => {
    const { identifier } = kind;
    // unnamed case
    if (!identifier) {
        const { signature } = kind;
        return {
            byIdentifierReference: {},
            unnamedBySignature: {
                [signature]: kind
            },
            globalIdentifiers: new Set([]),
            identifiersByContainer: {},
        };
    }
    const reference = identifier_1.Identifier.toReference(identifier);
    const { container } = identifier;
    // globally-defined case
    if (!container) {
        return {
            byIdentifierReference: {
                [reference]: kind
            },
            unnamedBySignature: {},
            globalIdentifiers: new Set([reference]),
            identifiersByContainer: {}
        };
    }
    // defined inside containing contract/interface
    const containerDeclarations = fromInterface({ identifier: container });
    const containerReference = identifier_1.Identifier.toReference(container);
    return (0, exports.merge)(containerDeclarations, {
        // defined inside interface case
        byIdentifierReference: {
            [reference]: kind,
        },
        unnamedBySignature: {},
        globalIdentifiers: new Set([]),
        identifiersByContainer: {
            [containerReference]: new Set([reference])
        }
    });
};
const fromInterface = (kind) => {
    const { identifier } = kind;
    if (!identifier) {
        return (0, exports.empty)();
    }
    const reference = identifier_1.Identifier.toReference(identifier);
    return {
        byIdentifierReference: {
            [reference]: kind,
        },
        unnamedBySignature: {},
        globalIdentifiers: new Set([reference]),
        identifiersByContainer: {}
    };
};
const mergeIdentifiersByContainer = (a, b) => [...new Set([
        ...Object.keys(a),
        ...Object.keys(b)
    ])]
    .map((containerReference) => ({
    [containerReference]: new Set([
        ...(a[containerReference] || []),
        ...(b[containerReference] || [])
    ])
}))
    .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
//# sourceMappingURL=types.js.map