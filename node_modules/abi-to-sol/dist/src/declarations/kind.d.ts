import { Identifier } from "./identifier";
import type { Type } from "../type";
export type MissingBindings = "missing-bindings";
export type MissingDeepBindings = "missing-deep-bindings";
export type HasBindings = "has-bindings";
export type Bindings = MissingBindings | MissingDeepBindings | HasBindings;
export type Kind<B extends Bindings = HasBindings> = Kind.Interface<B> | Kind.Elementary | Kind.Array<B> | Kind.Struct<B>;
export declare namespace Kind {
    interface Elementary {
        type: Type.Elementary;
        hints?: {
            internalType?: string;
        };
    }
    const isElementary: <B extends Bindings>(kind: Kind<B>) => kind is Elementary;
    interface UserDefinedValueType extends Elementary {
        identifier: Identifier;
        hints: {
            internalType: string;
        };
    }
    const isUserDefinedValueType: <B extends Bindings>(kind: Kind<B>) => kind is UserDefinedValueType;
    interface Array<B extends Bindings = HasBindings> {
        itemKind: Kind<B>;
        length?: number;
        hints?: {};
    }
    const isArray: <B extends Bindings>(kind: Kind<B>) => kind is Array<B>;
    namespace Array {
        interface Static<B extends Bindings> extends Array<B> {
            length: number;
        }
        const isStatic: <B extends Bindings>(kind: Kind<B>) => kind is Static<B>;
        interface Dynamic<B extends Bindings> extends Array<B> {
            length: never;
        }
        const isDynamic: <B extends Bindings>(kind: Kind<B>) => kind is Dynamic<B>;
    }
    type Struct<B extends Bindings = HasBindings> = {
        signature: string;
        hints?: {
            internalType?: string;
        };
    } & (B extends HasBindings ? {
        identifier: Identifier;
        members: Struct.Member<HasBindings>[];
    } : B extends MissingDeepBindings ? {
        identifier: Identifier;
        members: Struct.Member<MissingBindings>[];
    } : B extends MissingBindings ? {
        identifier?: Identifier;
        members: Struct.Member<MissingBindings>[];
    } : {
        identifier?: Identifier;
        members: Struct.Member<B>[];
    });
    const isStruct: <B extends Bindings>(kind: Kind<B>) => kind is Struct<B>;
    namespace Struct {
        interface Member<B extends Bindings> {
            name?: string;
            kind: Kind<B>;
        }
    }
    type Interface<B extends Bindings = HasBindings> = B extends HasBindings ? {
        identifier: Identifier;
    } : B extends MissingDeepBindings ? {
        identifier: Identifier;
    } : B extends MissingBindings ? {
        identifier?: Identifier;
    } : {
        identifier?: Identifier;
    };
    const isInterface: <B extends Bindings>(kind: Kind<B>) => kind is Interface<B>;
}
//# sourceMappingURL=kind.d.ts.map