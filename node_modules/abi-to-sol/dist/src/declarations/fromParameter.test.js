"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const abi_utils_1 = require("@truffle/abi-utils");
const identifier_1 = require("./identifier");
const fromParameter_1 = require("./fromParameter");
describe("fromParameter", () => {
    it("builds declarations from a single elementary type", () => {
        const parameter = {
            type: "uint256",
            name: "u",
            internalType: "uint256"
        };
        const { declarations, parameterKind } = (0, fromParameter_1.fromParameter)(parameter);
        expect(declarations.byIdentifierReference).toEqual({});
        expect(declarations.unnamedBySignature).toEqual({});
    });
    it("builds a reference to an unnamed struct", () => {
        const parameter = {
            type: "tuple",
            name: "s",
            components: [
                {
                    type: "uint256",
                    name: "u"
                }
            ]
        };
        const expectedSignature = (0, abi_utils_1.abiTupleSignature)(
        // default to satisfy type-checker (Abi.Parameter includes non-tuples)
        parameter.components || []);
        const { declarations, parameterKind } = (0, fromParameter_1.fromParameter)(parameter);
        expect(declarations.byIdentifierReference).toEqual({});
        expect(declarations.unnamedBySignature).toHaveProperty("(uint256)");
        const unnamedDeclaration = declarations.unnamedBySignature["(uint256)"];
        if (!unnamedDeclaration) {
            throw new Error("Expected unnamed reference");
        }
        expect(unnamedDeclaration.signature).toEqual(expectedSignature);
        expect(unnamedDeclaration.identifier).toEqual(undefined);
        expect(unnamedDeclaration.members).toHaveLength(1);
        const [member] = unnamedDeclaration.members;
        expect(member.name).toEqual("u");
        expect(member.kind).toEqual({
            type: "uint256"
        });
    });
    it("should deduplicate unnamed structs", () => {
        const internalComponent = {
            name: "u",
            type: "uint256"
        };
        const parameter = {
            name: "a",
            type: "tuple",
            components: [{
                    name: "b1",
                    type: "tuple",
                    components: [Object.assign({}, internalComponent)]
                }, {
                    name: "b2",
                    type: "tuple",
                    components: [Object.assign({}, internalComponent)]
                }]
        };
        const { declarations, parameterKind } = (0, fromParameter_1.fromParameter)(parameter);
        // outer struct
        expect(declarations.unnamedBySignature).toHaveProperty("((uint256),(uint256))");
        const outerStruct = declarations.unnamedBySignature["((uint256),(uint256))"];
        // inner struct
        expect(declarations.unnamedBySignature).toHaveProperty("(uint256)");
    });
    it("should include identifiers when given internalType", () => {
        const parameter = {
            name: "a",
            type: "tuple",
            internalType: "struct A",
            components: [{
                    name: "u",
                    type: "uint256"
                }, {
                    name: "f",
                    type: "address",
                    internalType: "contract Foo"
                }]
        };
        const { declarations, parameterKind } = (0, fromParameter_1.fromParameter)(parameter);
        if (!("identifier" in parameterKind)) {
            throw new Error("Expected `identifier` to exist on parameterKind");
        }
        const { identifier } = parameterKind;
        if (!identifier) {
            throw new Error("Expected identifier to be defined");
        }
        expect(declarations.byIdentifierReference).toHaveProperty(identifier_1.Identifier.toReference(identifier));
        const kind = declarations.byIdentifierReference[identifier_1.Identifier.toReference(identifier)];
        expect(parameterKind).toEqual(kind);
    });
});
//# sourceMappingURL=fromParameter.test.js.map