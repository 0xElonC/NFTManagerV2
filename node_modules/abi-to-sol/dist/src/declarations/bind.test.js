"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const identifier_1 = require("./identifier");
const fromParameter_1 = require("./fromParameter");
const bind_1 = require("./bind");
describe("bind", () => {
    it("should re-use the same identifier for the same unnamed struct", () => {
        const internalComponent = {
            name: "u",
            type: "uint256"
        };
        const parameter = {
            name: "a",
            type: "tuple",
            internalType: "struct A",
            components: [{
                    name: "b1",
                    type: "tuple",
                    components: [Object.assign({}, internalComponent)]
                }, {
                    name: "b2",
                    type: "tuple",
                    components: [Object.assign({}, internalComponent)]
                }]
        };
        const { declarations, parameterKind } = (0, fromParameter_1.fromParameter)(parameter);
        if (!("identifier" in parameterKind) || !parameterKind.identifier) {
            throw new Error("Expected parameterKind to have identifier");
        }
        const { identifier } = parameterKind;
        const declarationsWithBindings = (0, bind_1.bind)(declarations);
        const outerStructKind = declarationsWithBindings.byIdentifierReference[identifier_1.Identifier.toReference(identifier)];
        if (!("members" in outerStructKind)) {
            throw new Error("Expected outer struct to have `members`");
        }
        const { members: [b1, b2] } = outerStructKind;
        if (!("identifier" in b1.kind) || !("identifier" in b2.kind)) {
            throw new Error("Inner struct is missing identifier");
        }
        expect(b1.kind.identifier).toEqual(b2.kind.identifier);
    });
});
//# sourceMappingURL=bind.test.js.map