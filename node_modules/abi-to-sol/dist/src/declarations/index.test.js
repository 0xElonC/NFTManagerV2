"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fc = __importStar(require("fast-check"));
const jest_fast_check_1 = require("jest-fast-check");
const abi_utils_1 = require("@truffle/abi-utils");
const _1 = require(".");
const kind_1 = require("./kind");
const identifier_1 = require("./identifier");
describe("Declarations.collect", () => {
    describe("arbitrary examples", () => {
        describe("for non-tuple parameters / event parameters", () => {
            (0, jest_fast_check_1.testProp)("are empty", [fc.oneof(abi_utils_1.Arbitrary.Parameter(), abi_utils_1.Arbitrary.EventParameter())], (parameter) => {
                fc.pre(!parameter.type.startsWith("tuple"));
                expect(_1.Declarations.collect(parameter)).toEqual({
                    byIdentifierReference: {},
                    unnamedBySignature: {},
                    globalIdentifiers: new Set([]),
                    identifiersByContainer: {},
                });
            });
        });
        describe("for tuple parameters with non-tuple components", () => {
            (0, jest_fast_check_1.testProp)("have length 1", [fc.oneof(abi_utils_1.Arbitrary.Parameter(), abi_utils_1.Arbitrary.EventParameter())], (parameter) => {
                fc.pre(parameter.type.startsWith("tuple"));
                fc.pre(parameter.components.every((component) => !component.type.startsWith("tuple")));
                const declarations = _1.Declarations.collect(parameter);
                expect(Object.keys(declarations.byIdentifierReference)).toHaveLength(1);
                const [kind] = Object.values(declarations.byIdentifierReference);
                if (!("members" in kind)) {
                    throw new Error("Expected kind to be a struct with members");
                }
                const { members } = kind;
                expect(members).toHaveLength(parameter.components.length);
                for (const [index, member] of members.entries()) {
                    expect(member.name).toEqual(parameter.components[index].name);
                }
            });
        });
        describe("for tuple parameters with exactly one tuple component", () => {
            (0, jest_fast_check_1.testProp)("have length 2", [fc.oneof(abi_utils_1.Arbitrary.Parameter(), abi_utils_1.Arbitrary.EventParameter())], (parameter) => {
                fc.pre(parameter.type.startsWith("tuple"));
                // find exactly one tuple-based component
                const tupleComponents = parameter.components.filter((component) => component.type.startsWith("tuple"));
                fc.pre(tupleComponents.length === 1);
                const [tupleComponent] = tupleComponents;
                fc.pre(tupleComponent.components.every((component) => !component.type.startsWith("tuple")));
                const declarations = _1.Declarations.collect(parameter);
                expect(Object.keys(declarations.byIdentifierReference)).toHaveLength(2);
            });
        });
        (0, jest_fast_check_1.testProp)("produce only valid references to each other", [fc.oneof(abi_utils_1.Arbitrary.Parameter(), abi_utils_1.Arbitrary.EventParameter())], (parameter) => {
            fc.pre(parameter.type.startsWith("tuple"));
            const components = parameter.components || [];
            const declarations = _1.Declarations.collect(parameter);
            for (const kind of Object.values(declarations.byIdentifierReference)) {
                if ("members" in kind) {
                    for (const member of kind.members) {
                        if (kind_1.Kind.isStruct(member.kind)) {
                            if (!("identifier" in member.kind)) {
                                throw new Error("Expected identifier");
                            }
                            expect(declarations.byIdentifierReference).toHaveProperty(identifier_1.Identifier.toReference(member.kind.identifier));
                        }
                    }
                }
            }
        });
    });
});
//# sourceMappingURL=index.test.js.map