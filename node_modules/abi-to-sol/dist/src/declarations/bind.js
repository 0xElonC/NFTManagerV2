"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bind = void 0;
const identifier_1 = require("./identifier");
const kind_1 = require("./kind");
const types_1 = require("./types");
const bind = (declarations) => {
    const { newDeclarations, identifierBySignature, } = Object.entries(declarations.unnamedBySignature || {})
        .map(([signature, unidentifiedKind], index) => {
        const identifier = {
            class: "struct",
            name: `S_${index}`
        };
        const kind = Object.assign(Object.assign({}, unidentifiedKind), { identifier });
        return {
            kind,
            signature
        };
    })
        .reduce(({ newDeclarations: { byIdentifierReference, globalIdentifiers }, identifierBySignature }, { kind, signature }) => ({
        newDeclarations: {
            byIdentifierReference: Object.assign(Object.assign({}, byIdentifierReference), { [identifier_1.Identifier.toReference(kind.identifier)]: kind }),
            unnamedBySignature: {},
            globalIdentifiers: new Set([
                ...globalIdentifiers,
                identifier_1.Identifier.toReference(kind.identifier)
            ]),
            identifiersByContainer: {},
        },
        identifierBySignature: Object.assign(Object.assign({}, identifierBySignature), { [signature]: kind.identifier })
    }), {
        newDeclarations: {
            byIdentifierReference: {},
            unnamedBySignature: {},
            globalIdentifiers: new Set([]),
            identifiersByContainer: {}
        },
        identifierBySignature: {}
    });
    const declarationsMissingDeepBindings = (0, types_1.merge)(declarations, newDeclarations);
    return {
        byIdentifierReference: Object.entries(declarationsMissingDeepBindings.byIdentifierReference)
            .map(([identifierReference, kind]) => ({
            [identifierReference]: kind_1.Kind.isStruct(kind)
                ? bindStruct(kind, identifierBySignature)
                : kind
        }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}),
        unnamedBySignature: {},
        globalIdentifiers: declarationsMissingDeepBindings.globalIdentifiers,
        identifiersByContainer: declarationsMissingDeepBindings.identifiersByContainer
    };
};
exports.bind = bind;
const bindKind = (kind, identifierBySignature) => {
    if (kind_1.Kind.isElementary(kind)) {
        return kind;
    }
    if (kind_1.Kind.isUserDefinedValueType(kind)) {
        return kind;
    }
    if (kind_1.Kind.isStruct(kind)) {
        return bindStruct(kind, identifierBySignature);
    }
    if (kind_1.Kind.isArray(kind)) {
        return bindArray(kind, identifierBySignature);
    }
    throw new Error("Could not recognize kind");
};
const bindStruct = (kind, identifierBySignature) => {
    const { signature, identifier = identifierBySignature[signature] } = kind;
    const members = kind.members.map(({ name, kind }) => ({
        name,
        kind: bindKind(kind, identifierBySignature)
    }));
    return {
        signature,
        members,
        identifier
    };
};
const bindArray = (kind, identifierBySignature) => {
    const itemKind = bindKind(kind.itemKind, identifierBySignature);
    const length = kind.length;
    return Object.assign({ itemKind }, ("length" in kind
        ? { length }
        : {}));
};
//# sourceMappingURL=bind.js.map