import { Identifier } from "./identifier";
import { Bindings, HasBindings, MissingDeepBindings, MissingBindings, Kind } from "./kind";
export type Declarations<B extends Bindings = MissingBindings> = {
    byIdentifierReference: {
        [reference: Identifier.Reference]: Kind.Interface<B> | Kind.UserDefinedValueType | Kind.Struct<B>;
    };
    unnamedBySignature: UnnamedBySignature<B>;
    globalIdentifiers: Set<Identifier.Reference>;
    identifiersByContainer: {
        [reference: Identifier.Interface.Reference]: Set<Identifier.Reference>;
    };
};
export type UnnamedBySignature<B extends Bindings = MissingBindings> = B extends HasBindings ? {
    [signature: string]: never;
} : B extends MissingDeepBindings ? {
    [signature: string]: undefined;
} : B extends MissingBindings ? {
    [signature: string]: Kind.Struct<B>;
} : {
    [signature: string]: Kind.Struct<B>;
};
/**
 * Initialize an empty set of declarations
 */
export declare const empty: <B extends Bindings>() => Declarations<B>;
/**
 * Merge two sets of declarations
 */
export declare const merge: <B extends Bindings>(a: Declarations<B>, b: Declarations<B>) => Declarations<B>;
/**
 * Generate declarations to include a single Kind.
 * Note! This does not recurse; e.g. it returns empty() for arrays always
 */
export declare const from: <B extends Bindings>(kind: Kind<B>) => Declarations<B>;
//# sourceMappingURL=types.d.ts.map