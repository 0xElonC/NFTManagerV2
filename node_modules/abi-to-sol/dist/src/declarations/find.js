"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.find = void 0;
const parameter_1 = require("../parameter");
const identifier_1 = require("./identifier");
const kind_1 = require("./kind");
const find = (parameter, declarations) => {
    const { type } = parameter;
    if (!(0, parameter_1.isParameter)(parameter)) {
        throw new Error(`Parameter type \`${parameter.type}\` is not a valid ABI type`);
    }
    if (parameter_1.Parameter.isElementary(parameter)) {
        return findElementary(parameter, declarations);
    }
    if (parameter_1.Parameter.isArray(parameter)) {
        return findArray(parameter, declarations);
    }
    if (parameter_1.Parameter.isTuple(parameter)) {
        return findTuple(parameter, declarations);
    }
    throw new Error(`Unknown type ${type}`);
};
exports.find = find;
const findElementary = (parameter, declarations) => {
    if (!parameter_1.Parameter.isUserDefinedValueType(parameter)) {
        const { type, internalType } = parameter;
        return Object.assign({ type }, (internalType
            ? { hints: { internalType } }
            : {}));
    }
    const { name, scope } = parameter_1.Parameter.UserDefinedValueType.recognize(parameter);
    const identifier = identifier_1.Identifier.UserDefinedValueType.create({ name, scope });
    const reference = identifier_1.Identifier.toReference(identifier);
    const kind = declarations.byIdentifierReference[reference];
    if (!kind) {
        throw new Error(`Unknown declaration with identifier reference ${reference}`);
    }
    return kind;
};
const findArray = (parameter, declarations) => {
    const itemParameter = parameter_1.Parameter.Array.item(parameter);
    const itemKind = (0, exports.find)(itemParameter, declarations);
    return Object.assign({ itemKind }, (parameter_1.Parameter.Array.isStatic(parameter)
        ? { length: parameter_1.Parameter.Array.Static.length(parameter) }
        : {}));
};
const findTuple = (parameter, declarations) => {
    const { signature, name, scope } = parameter_1.Parameter.Tuple.recognize(parameter);
    const identifier = name
        ? identifier_1.Identifier.Struct.create({ name, scope })
        : undefined;
    if (identifier) {
        const reference = identifier_1.Identifier.toReference(identifier);
        const kind = declarations.byIdentifierReference[reference];
        if (!kind) {
            throw new Error(`Unknown declaration with identifier reference ${reference}`);
        }
        return kind;
    }
    // reaching here guarantees no internalType specified for `parameter`
    // so only match declarations that also have no internalType
    const kind = Object.values(declarations.byIdentifierReference)
        .find(kind => {
        var _a;
        return kind_1.Kind.isStruct(kind) &&
            kind.signature === signature &&
            !((_a = kind.hints) === null || _a === void 0 ? void 0 : _a.internalType);
    });
    if (!kind) {
        throw new Error(`Unknown declaration with tuple signature ${signature}`);
    }
    return kind;
};
//# sourceMappingURL=find.js.map