"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parameter = exports.isParameter = void 0;
const abi_utils_1 = require("@truffle/abi-utils");
const type_1 = require("./type");
const isParameter = (parameter) => (0, type_1.isType)(parameter.type);
exports.isParameter = isParameter;
var Parameter;
(function (Parameter) {
    Parameter.isElementary = (parameter) => type_1.Type.isElementary(parameter.type);
    Parameter.isUserDefinedValueType = (parameter) => Parameter.isElementary(parameter) &&
        !!parameter.internalType &&
        parameter.internalType !== parameter.type &&
        UserDefinedValueType.internalTypePattern.test(parameter.internalType);
    let UserDefinedValueType;
    (function (UserDefinedValueType) {
        UserDefinedValueType.internalTypePattern = new RegExp(/^(([a-zA-Z$_][a-zA-Z0-9$_]*)\.)?([a-zA-Z$_][a-zA-Z0-9$_]*)$/);
        UserDefinedValueType.recognize = (parameter) => {
            const { type, internalType } = parameter;
            if (!internalType || internalType === type) {
                return undefined;
            }
            const match = internalType.match(UserDefinedValueType.internalTypePattern);
            if (!match) {
                return undefined;
            }
            const scope = match[2];
            const name = match[3];
            return Object.assign({ name }, (scope
                ? { scope }
                : {}));
        };
    })(UserDefinedValueType = Parameter.UserDefinedValueType || (Parameter.UserDefinedValueType = {}));
    Parameter.isArray = (parameter) => type_1.Type.isArray(parameter.type);
    let Array;
    (function (Array) {
        Array.item = (parameter) => {
            const type = type_1.Type.Array.underlying(parameter.type);
            let internalType;
            {
                const match = (parameter.internalType || "").match(/^(.+)\[[^\]]*\]$/);
                if (match) {
                    const [_, underlying] = match;
                    internalType = underlying;
                }
            }
            return Object.assign(Object.assign(Object.assign({}, parameter), { type }), (internalType && internalType !== "tuple"
                ? { internalType }
                : {}));
        };
        Array.isStatic = (parameter) => type_1.Type.Array.isStatic(parameter.type);
        let Static;
        (function (Static) {
            Static.length = (parameter) => type_1.Type.Array.length(parameter.type);
        })(Static = Array.Static || (Array.Static = {}));
    })(Array = Parameter.Array || (Parameter.Array = {}));
    Parameter.isTuple = (parameter) => type_1.Type.isTuple(parameter.type);
    let Tuple;
    (function (Tuple) {
        Tuple.internalTypePattern = new RegExp(/^struct (([a-zA-Z$_][a-zA-Z0-9$_]*)\.)?([a-zA-Z$_][a-zA-Z0-9$_]*)$/);
        Tuple.recognize = (parameter) => {
            if (!Parameter.isTuple(parameter)) {
                return undefined;
            }
            const signature = (0, abi_utils_1.abiTupleSignature)(parameter.components);
            if (!parameter.internalType) {
                return { signature };
            }
            const match = parameter.internalType.match(Tuple.internalTypePattern);
            if (!match) {
                return { signature };
            }
            const scope = match[2];
            const name = match[3];
            return Object.assign({ signature,
                name }, (scope
                ? { scope }
                : {}));
        };
    })(Tuple = Parameter.Tuple || (Parameter.Tuple = {}));
})(Parameter = exports.Parameter || (exports.Parameter = {}));
//# sourceMappingURL=parameter.js.map