"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isType = exports.Type = exports.isNaturalLessThanEqualToThirtyTwo = exports.isNaturalLessThanEqualToEighty = exports.isWhole = exports.isOctal = void 0;
const isOctal = (expression) => {
    const integer = parseInt(expression, 10);
    if (expression !== `${integer}`) {
        return false;
    }
    return integer % 8 === 0 && integer >= 8 && integer <= 256;
};
exports.isOctal = isOctal;
const isWhole = (expression) => {
    const integer = parseInt(expression, 10);
    if (expression !== `${integer}`) {
        return false;
    }
    return integer >= 0;
};
exports.isWhole = isWhole;
const isNaturalLessThanEqualToEighty = (expression) => {
    const integer = parseInt(expression, 10);
    if (expression !== `${integer}`) {
        return false;
    }
    return integer > 0 && integer <= 80;
};
exports.isNaturalLessThanEqualToEighty = isNaturalLessThanEqualToEighty;
const isNaturalLessThanEqualToThirtyTwo = (expression) => {
    const integer = parseInt(expression, 10);
    if (expression !== `${integer}`) {
        return false;
    }
    return integer > 0 && integer <= 32;
};
exports.isNaturalLessThanEqualToThirtyTwo = isNaturalLessThanEqualToThirtyTwo;
var Type;
(function (Type) {
    let Elementary;
    (function (Elementary) {
        Elementary.isUint = (expression) => expression === "uint" || (expression.startsWith("uint") &&
            (0, exports.isOctal)(expression.slice(4)));
        Elementary.isInt = (expression) => expression === "int" || (expression.startsWith("int") &&
            (0, exports.isOctal)(expression.slice(3)));
        Elementary.isAddress = (expression) => expression === "address";
        Elementary.isBool = (expression) => expression === "bool";
        Elementary.isUfixed = (expression) => {
            if (expression === "ufixed") {
                return true;
            }
            const match = expression.match(/^ufixed([^x]+)x([^x]+)$/);
            if (!match) {
                return false;
            }
            const [_, m, n] = match;
            return (0, exports.isOctal)(m) && (0, exports.isNaturalLessThanEqualToEighty)(n);
        };
        Elementary.isFixed = (expression) => {
            if (expression === "fixed") {
                return true;
            }
            const match = expression.match(/^fixed([^x]+)x([^x]+)$/);
            if (!match) {
                return false;
            }
            const [_, m, n] = match;
            return (0, exports.isOctal)(m) && (0, exports.isNaturalLessThanEqualToEighty)(n);
        };
        Elementary.isStaticBytes = (expression) => expression.startsWith("bytes") &&
            (0, exports.isNaturalLessThanEqualToThirtyTwo)(expression.slice(5));
        Elementary.isBytes = (expression) => expression === "bytes";
        Elementary.isString = (expression) => expression === "string";
        Elementary.isFunction = (expression) => expression === "function";
    })(Elementary = Type.Elementary || (Type.Elementary = {}));
    Type.isElementary = (expression) => Elementary.isUint(expression) ||
        Elementary.isInt(expression) ||
        Elementary.isAddress(expression) ||
        Elementary.isBool(expression) ||
        Elementary.isUfixed(expression) ||
        Elementary.isFixed(expression) ||
        Elementary.isStaticBytes(expression) ||
        Elementary.isBytes(expression) ||
        Elementary.isString(expression) ||
        Elementary.isFunction(expression);
    let Array;
    (function (Array) {
        Array.isStatic = (expression) => {
            const match = expression.match(/^(.+)\[([0-9]+)\]$/);
            if (!match) {
                return false;
            }
            const [_, underlying, length] = match;
            return (0, exports.isType)(underlying) && (0, exports.isWhole)(length);
        };
        Array.length = (type) => {
            const match = type.match(/\[([0-9]+)\]$/);
            if (!match) {
                throw new Error(`Unexpected mismatch, type \`${type}\` is not a valid static array`);
            }
            const [_, length] = match;
            return parseInt(length, 10);
        };
        Array.isDynamic = (expression) => {
            const match = expression.match(/^(.+)\[\]$/);
            if (!match) {
                return false;
            }
            const [_, underlying] = match;
            return (0, exports.isType)(underlying);
        };
        Array.underlying = (type) => {
            const match = type.match(/^(.+)\[[^\]]*\]$/);
            if (!match) {
                throw new Error(`Unexpected mismatch, \`${type}\` is not a valid array type`);
            }
            const [_, underlying] = match;
            if (!(0, exports.isType)(underlying)) {
                throw new Error(`Underlying type \`${underlying}\` is not a valid type`);
            }
            return underlying;
        };
    })(Array = Type.Array || (Type.Array = {}));
    Type.isArray = (expression) => Array.isStatic(expression) ||
        Array.isDynamic(expression);
    Type.isTuple = (expression) => expression === "tuple";
})(Type = exports.Type || (exports.Type = {}));
const isType = (expression) => Type.isElementary(expression) ||
    Type.isArray(expression) ||
    Type.isTuple(expression);
exports.isType = isType;
//# sourceMappingURL=type.js.map